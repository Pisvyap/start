# Typlyp
Сделан тяпляп

# Синтаксис
## Переменные и арифметика
Привычных присваиваний больше нет, направляй данные туда куда хочется, в любом направлении
```
x: chislo <- 10;
x + 90 -> x;
x -> glaza;
```

## Условия
Теперь можно писать нормальные сравнения без `==`
```
esli (x = 18) {
    da -> glaza;
} inache {
    net -> glaza;
}
```
## Циклы
```
k: chislo <- 0;
poka (k < 10) {
    glaza <- k;
    k + 1 -> k;
}
```

Точки с запятой прошлый век, так выглядит намного эстетичнее
```
perebor (k: chislo <- 1 | k <= 10 | k + 1 -> k + 1) {
    k -> glaza;
}
```

## Массивы

```
arr: chislo<> <- new chislo<10>;
perebor (k: chislo <- 0; k < 10; k <- k + 1) {
    k * k -> arr[k];
}

arr[0] -> glaza;
```

## Функции
Все данные для функции складываются в коробочку и отправляются прямо в саму функцию
```
delo foo (a: chislo, b: chislo) -> logika {
    otday a + b;
}

[1, 2] -> foo -> glaza;
```

---

# Стек
Есть два варианта исполнения программы, которые выбираются с помощью флага при запуске:
1. **-С** - LLVM и его байткод.
2. **-I** - собственный байткод и интерпретатор

для построения AST использована библиотека ANTLR4

## Небольшое введение
### Testcases
Женя уже написал целиком три программы, которые мы будем показывать для защиты языка.
Они находятся в `/scratches`. Может будет полезно, чтобы понять какие 
конструкции используются

### Точка входа в программу
Пока что это `main.cpp`, там небольшой скриптик, который читает входной файл
и пропускает его через ANTLR.

### ANTLR4
Лексер, парсер, токенайзер, короче **всё**, что связано с синтаксисом и грамматикой языка
работает с помощью библиотеки ANTLR4

---

Для работы с ней можно загрузить [удобный плагин](https://plugins.jetbrains.com/plugin/7358-antlr-v4)
для ide. Ему можно скормить текст нашего языка (или файлик из `/scratches`) и он его
распарсит. Можно посмотреть как выглядит дерево парсинга и из каких
конструкций состоит язык
#### Описание грамматики
В этом фреймворке вся грамматика описывается единственным файлом **typlyp.g4**
Можно его полистать, может быть полезно, чтобы понять, какие бывают выражения,
утверждения и т.п.

Дальше с помощью тулзы (которую можно взять с гх antlr4), либо с помощью плагина для
ide генерируются .h и .cpp файлы для парсинга и составления **parse tree**.

Все файлы связанные с этой частью лежат в `/grammar`

---

#### Построение AST
Дальше по идее нужно из этого дерева парсинга построить абстрактное синтаксическое дерево.
<u>Пока что</u> непонятно чем оно критически отличается от дерева парсинга, которое
ANTLR и так умеет строить. Я предполагаю, что AST - просто удобный маппинг этого дерева
на ООП, так чтобы потом было удобно прикручивать LLVM

---
Всё, что связано с AST лежит в `/ast`
- `ASTNode.h` - базовый узел АСТ-дерева
- `/nodes` - реализации остальных узлов дерева
- `ASTBuilder.h` - строитель дерева, наследуется от `/grammar/typlypBaseVisitor.h`. В него
передаем начальный узел (`nodes/ProgramNode.h`) и он строит с него дерево
---
Суть проста, сейчас дерево парсинга состоит из оч непонятных сложных классов, в которых
много лишнего. нужно переложить их в понятные красивые хайповые классы.

Ну и к тому же классы дерева парсинга менее детальны чем планируемое дерево АСТ.
Например, планируется что в АСТ будет отдельная нода для бинарной операции, а в дереве
парсинга такого нет!!

---

#### Работа с llvm.

Добавил llvm-project как git submodule, при pull вам нужно еще сделать команду git submodule update --init --recursive 

Скачается llvm сурс файлы(+- 3 гб). Могут быть проблемы с clrf и rf читай предупреждения, которые может кидать гит

Чтобы сбилдить сам llvm нужны cmake(https://community.chocolatey.org/packages/cmake)
(https://community.chocolatey.org/packages/cmake.portable) ставить оба, первый ставить через такую команду choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System')
и ninja(https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages),
их нужно установить, удобнее всего через менеджеры пакетов(https://chocolatey.org/install), ссылки чуть раньше. 

Может выскачить ошибка при билде, 

Что бы сделать билд нужно прописать
- cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug (Release, RelWithDebInfo)
- ninja -C build check-llvm
- Debug - дебаг, долго компилится - дает много дебаг инфы
- Release - быстро компилится - ноль дебаг инфы
- RelWithDebInfo - что-то среднее между Debug и Release
- Подробнее тут https://llvm.org/docs/GettingStarted.html

Теперь в папке build должны появиться нужные файлы для работы кодгена, нужно подключить их через cmake файл

---

#### Как заставить все работать вместе
1. Сборка должна быть установлена **релизная** (В CLion надо вверху выбрать Release а не Debug)
без этого ничего работать не будет
2. В директории `antlr4-runtime` теперь хранится ANTLR4, библиотеки уже подключены в cmake.
**НО!** После того как CMake отработает и появится папка `cmake-build-release`, внутрь
неё нужно скопировать файл `antlr4-runtime.dll`, так чтобы он лежал рядом с исполняемым файлом `typlyp.exe`
3. В целом, после этого должно заработать (по крайней мере у меня работает)

#### Собираем gc
1. С помощью``git submodule``, либо ``git clone`` клонируем https://github.com/ivmai/bdwgc
2. В PowerShell ставим сначала Scoop (https://scoop.sh/), потом Zig compiler(``scoop install zig``)
3. Так же в шеле заходим в дерикторию ``../bdwgc/`` и там прописываем ``zig build``, после чего в этой же дериктори появляется zig-out
4. После чего можно запускать CMakeLists
5. По аналогии с `antlr4-runtime.dll` перекидываем файл ``gc.dll`` (лежит в ``/bdwgc/zig-out/bin/``) на один уровень с `typlyp.exe`
6. Должно заработать)

